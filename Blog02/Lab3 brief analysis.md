# 关于Lab3的问题提示与初步分析

> 说明：
>
> * 本篇blog仅针对[HIT 2021春 Software Construction Lab3](https://github.com/Edmund-Lai/JavaBlog/blob/main/Blog02/instruction.pdf)
> * 由于本次的Lab几乎没有任何往届的材料参考，所有的分析仅代表个人观点，欢迎任何的讨论与批评指正
> * 基本按照Lab3的实验指导的顺序进行说明，重点在于个人开发时遇到的问题
> * blog中所有的标题都是实验指导中对应的标题
> * 本篇blog的内容并非全面、也并非对Lab3全部内容的分析，本人仍然在逐步完善中
> * 希望您在**已经完整地阅读过至少一遍的实验指导后**再参考本篇blog
> * 由于各种原因本人暂时恕不上传源代码，如有需要请私下联系

## 3.1 IntervalSet与待开发的应用场景

理解这个ADT是本次实验的核心，实验指导中定义它为**在特定时间段进行的特定任务**。

给出的三个场景分别是值班表管理、线程调度管理、课表管理，在我们设计ADT时**某些细节比较模糊时通过可以考虑实际情况理解这些细节的处理**。我们现在只需要注意这里对不同的应用场景给出的一些限定，以下是本人提取的要点：

值班表管理：

* **每天**只能安排**唯一**一个员工在单位值班
* 不能出现某天无人值班的情况
* 员工若被安排值班 m 天 (m>1)，那么需要安排在**连续的 m 天**内

线程调度管理：

* 每个时间**只能有一个进程在执行**，其他进程处于休眠状态
* 在特定时刻，**CPU 可以“闲置”**

课表管理：

* 各周的课表都是完全一样的，所有的课程安排以周为单位
* 一门课程每周可以出现 1 次，也可以安排多次
* 同一个时间段内可以安排不同的课程

## 3.2 IntervalSet\<L\>与MultiIntervalSet\<L\>

简单来说，这两个ADT都用于表示在特定时间段进行的特定任务，唯一的区别在于**标签对象L能否被绑定在多个时间段上**

这里我们需要做出本次实验的第一个决策，也是本人在设计ADT时考虑的第一个问题：对于“时间段”，我们如何正确而有效地进行表示？

一方面，参考实验指导给出的图：

<img src="https://github.com/Edmund-Lai/JavaBlog/blob/main/Blog02/figure1.png" alt="figure1" style="zoom: 67%;" />

从图中和本能反应来说我们会很轻易地想到时间段是一个连续的概念。

另一方面，我们回顾一下3.1节给出的三个具体场景，不难得出：

* 值班表安排场景下，我们关心的仅仅是一天，而不关心这一天中的具体时间
* 线程调度场景和课表场景下，我们可以使用一个开始时间和一个结束时间表示一段时间

同时，我们现实生活中对时间段的度量也倾向于**用一个开始的时间和一个结束的时间表示一个时间段**，但是有时这种表述非常**模糊**，并且存在习惯性的问题，下面给出几个例子：

1. “6月1日到6月7日”，按日常的理解，一般包含1号和7号这两天，同时我们用这两个**离散**的数据“6月1日”和“6月7日”，有效表示了这一段时间

2. “第一秒到第二秒”，这个是一个有歧义的表述，是否包含整个第二秒呢？因此我们用“1”和“2”两个离散数据对时间进行描述时就会存在歧义，这种歧义需要程序员自己进行规定，从而消除歧义

3. “8点到10点”，按日常的理解，这里不包含10:00开始的一个小时，虽然我们用“8”和“10”两个离散数据虽然也有效地表示了一个时间段，但是和上面第一种情况不一样的是，这里的“10”却不包含10:00开始的那一个小时

从这三个例子需要意识到：**使用离散的数据表示连续的时间时，会存在确定的情况和模糊的情况，确定的情况之间也有差别**，这个问题是我们设计时必须**做好约定**以消除歧义的。

在这一步我们只需要注意到这个问题即可，暂时没有继续分析下去的必要了。

## 3.3 ADT 的设计与实现

为了方便，这里本人同时对IntervalSet\<L\>与MultiIntervalSet\<L\>两个ADT进行分析

实验指导中明确了IntervalSet\<L\>是一个接口，但是保留了MultiIntervalSet\<L\>是接口、抽象类还是具体类，同时给出了两个ADT中的基本的方法。比较它们可以知道其实这两个ADT中相当一部分的方法是一样的(此时您可以考虑将二者抽象成一个更高层的ADT，事实上本人也是这么做的)。已经给出的方法都是非常清晰的，本人这里不赘述。

这里想提出本人遇到的第二个问题，以IntervalSet\<L\>为例，这个IntervalSet\<L\>到底表示什么？之前给出的定义是**在特定时间段进行的特定任务**，但是实验指导中有如下的方法描述：

> * 获得当前对象中的标签集合：Set labels()
> *  从当前对象中移除某个标签所关联的时间段：boolean remove(L  label) 
> * 返回某个标签对应的时间段的开始时间：long start (L label) 
> * 返回某个标签对应的时间段的结束时间：long end (L label)

这些方法显然是对于**一组标签或某个特定标签**的操作，加上它的名称中有“Set”，所以个人认为更明确的表达应该是**在一些特定时间段及时间段内特定任务的集合**，它表示的不应当是某个时间段，而是这些时间段及其标签的集合。

这里衍生出两个问题：

1. 我们应该怎么表示这样集合？使用List还是Set，或者其它方法？

2. 我们应该怎么表示集合中的元素？

对于第一个问题，这里本人暂时不发表看法，您可以通过分析做出自己的选择，本人这里使用的是ArrayList\<L\>将所有的Interval聚合到这个类中

对于第二个问题，比较方便的做法是再定义一个Interval类，这个类中的Rep包括一个标签对象，一个表示开始时间的变量start、一个表示结束时间的变量end。这里就涉及到3.2节中的问题，这样的设计可以有效、无歧义地表示时间段吗？

* 值班表查询：我们可以用6月1号、6月7号两个离散的数据表示这个时间段
* 线程调度：我们可以用例如1000、2000两个离散的数据表示CPU内部的时钟第1000次click到第2000次click中做的所有事
* 课表安排：我们可以用8、10两个离散的数据表示第一节课这一个时间段(~~万恶的早八，bushi~~)
* 作出规定：end不包含第end个单位时间，也就是说要表示生活中”6月1号到6月7号“，我们实际要使用可能”6-1“和”6-8“这样的数据来表示。当然这个规定您可以按照自己的习惯来定。

这里我们就解决了离散型数据表示时间时产生歧义问题。

**注意**：这里只是我们程序内部的表示，从用户的角度观察时，必须保证这种表示要符合日常的习惯。

对于两个ADT的实现类CommonIntervalSet\<L\>与CommonMultiIntervalSet\<L\>这里本人不赘述。

## 3.4 实际应用中的变化

这一节涉及到ADT怎么有效扩展到三个实际应用，实验指导中给出了三个维度的差异，我们这里需要加上上一节中IntervalSet\<L\>与MultiIntervalSet\<L\>的差异，那么一共就会有四个差异：

* 是否允许同一个interval映射到时间轴上的多个时间段

* 是否允许时间轴上有空白
* 是否允许不同的interval之间有重叠
* 是否包含周期的时间段

稍加分析便可知道：

|   场景   | 映射到多个时间段 | 是否能有空白 | 是否能重叠 | 是否有周期性 |
| :------: | :--------------: | :----------: | :--------: | :----------: |
|   值班   |      不可以      |    不可以    |   不可以   |     没有     |
| 线程调度 |       可以       |     可以     |   不可以   |     没有     |
|   课表   |       可以       |     可以     |    可以    |      有      |

在有了上述的分析结果后，我们再阅读实验指导的六种方案，可以更好地进行权衡

这里本人选择的是方案6：使用装饰模式，这里需要提前声明：本人在进行实践后并不觉得装饰模式在这里是一个很聪明的选择，事实上在进行开发时发现了很多问题(具体原因稍后再分析)，但还是使用它做下去了，如果您有更好的见解欢迎提出！

### 什么是装饰模式？

> 装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。

如果您对I/O流非常熟悉，想一想节点流和处理流的关系，您应该能很快理解到装饰模式的精髓：

```java
FileReader fr = new FileReader(new File(filename));
BufferedReader br = new BufferedReader(fr);//对FileReader类对象进行装饰
```

对于结点流我们可以用多个处理流进行包装，每一次的包装，都是对原来流**功能的增强**，这样我们可以用较小的类组合出多种扩展的功能。

如果您想进一步了解装饰模式，这里给出两个装饰模式讲解的链接

* [链接一](https://refactoringguru.cn/design-patterns/decorator)

* [链接二](http://c.biancheng.net/view/1366.html)

### 装饰模式在这个场景中的问题

在我们实现CommonIntervalSet\<L\>与CommonMultiIntervalSet\<L\>后，稍加思考我们可以发现：之前我们分析的四个维度的差别，”是否允许同一个interval映射到时间轴上的多个时间段“这个取决于具体的子类继承哪个父类，但是剩下三个维度，如果在设计之初不加以限制的话，空白是可以有的、重叠也是可以有的、周期型的有无和ADT的设计本身无关。

这就产生了一个矛盾：我们设计包装类的行为此时变成了一个**对原有功能的限制，而非加强**！这和设计模式的初衷是有些相悖的。这是本人认为装饰模式在这个场景中并不是非常适用的原因。

本人在最终的选择是用包装类对具体子类进行装饰，装饰后调用一个check方法，对interval的情况进行检查，个人感觉这种设计有些无趣和生硬。

### Update1 : 方法改进

本人又想到一种思路，这种思路在实验指导中并没有提到，但是个人认为会比实验指导中的六种方法都要简单，思路是：

1. 创建工具类，在工具类中提供面向IntervalSet接口或者更高层接口的方法，用于检查是否有空白、是否能够重叠
2. 在最顶层的接口中声明一个check方法，在抽象父类IntervalSet\<L\>与MultiIntervalSet\<L\>不对这个方法进行实现，将这个职责交给子类处理
3. 具体子类必须实现这个check方法，但子类中可以选择空实现这个方法(方法体为空)，或者根据对空白、重叠的要求组合调用工具类中的方法，具体子类在需要的时候直接在内部调用这个check方法就可以实现对时间段的检查

上述方法的好处在将check实际实现的逻辑放在工具类中完成，那么这样既不会产生继承关系、又不会产生接口数量过多问题。同时保证了所有具体子类必须实现check方法，并且这个方法的自由度很高，因为可以自由组合工具类中用于限制的操作。再者，也不会出现像上面本人最初那样用装饰模式非常别扭的情况。

### 面向各应用的ADT子类型

这里只做一个提醒，这一小节中实验指导给出了一个参考结构图：

<img src="https://github.com/Edmund-Lai/JavaBlog/blob/main/Blog02/figure2.png" alt="figure2" style="zoom:67%;" />

个人的建议是：这张图仅仅作为参考，实际的情况最好按照您自己选择的方案进行设计，这里没有什么限制(~~本人被这张图坑惨了~~)。

## 3.5 面向复用的设计：L

这一节只需按照实验指导进行设计即可，都是简单的pojo，不赘述

## 3.6 可复用API设计与开发

我们在3.3节中做好的规定在这一节中能充分发挥它效果，不过还是存在一些问题。

这一节中我们需要面向父类设计相关的API，也就是工具类。如果我们没有在3.3节中做好规定，那么我们就需要在这里考虑每个子类的情况，比如计算日期的冲突我们要加上最后一天，算小时的冲突我们又要忽略最后一小时，这样我们无法设计出统一的工具类方法供所有子类使用。

换而言之，我们**把解决歧义的职责吩咐给了每一个子类，而工具类只负责提供面向所有子类的方法**。职责分离是我们设计时非常重要的一个原则，进一步说，以后所有针对父类设计的方法，所有子类都可以使用，子类内部只需要解决歧义问题就可以正常使用这些方法。

不过这里仍然存在一些细节问题，这些问题也是我按照上面的思路开发到这里才发现的：

* 对于时间段不可重叠的情况，通过比较大小从而判断是否重叠时，需要考虑是否需要带等号。由于我们规定“6-8”这种数据是8号当天是不属于时间段的，所以另一个以“6-8”为开始时间点的时间段和前面这个时间段没有重叠
* 对于课表的设计，由于每周的课都是一样的，那我们事实上**只需要考虑每周的课即可**，相当于我们变相去除了周期性这个问题，周期性的表现我们可以在子类内部加上一个Rep表示教学周数目即可。
* 对于课表的空闲时间和重叠时间，有效时间只有每天的8:00-12:00、13:00-17:00、19：00-21：00这些时间段，在计算时注意排除其它时间

## 3.7 应用设计与实现

这一节的细节非常多，且都必须是实际自己开发GUI时才会发现的，这里本人只提出问题，解决方案并不全部给出，相信您一定可以自行解决。

### 共同问题

* 用户所有的输入都是以String类的对象接收并出现在程序中的，**您需要显式地提示用户以您希望的格式输入**，否则解析将是相当困难的事
* 所有的表格数据打印的触发事件不仅仅只有**用户修改数据的逻辑后**，也包括**用户进行简单查看的逻辑后**。以课程表系统为例，用户添加、删除一门课显然课表需要刷新，但是用户关闭课程表页面后如果什么也不做再次打开课程表页面也需要打印课表。**否则就变成了用户必须修改课表才会显示课表**，这一点非常容易被忽略
* 您在开发结束后需要反复地查找各种不合理的输入，个人的建议是先开发一个假定所有输入都合法的系统，在这个系统实现后，再去考虑非法输入的问题，对于每一种非法输入都要给出合理的提示
* 对已经添加的对象进行操作时，我们根据用户输入的数据怎么在集合中找到这个对象，这涉及您设计的pojo是否存在主键，同时这也是一个和用户的约定问题，您也需要显式地指出

### 值班管理系统

* 实验指导的step2中有一个个人认为不太合理的地方：

  > **增加一组员工**，……

  在程序中我们可以轻易地一组一组处理，但是实际情况中，我们在手动安排时并不会一组一组地安排，能够想象到的场景一般是选择某一个员工进行安排

* 这个细节要注意：

  > 如果某个员工已经被编排进排班表，那么他不能被删除，必须**将其排班信息删掉之后才能删除该员工**

* 这个值班系统要求值班表必须完全排满，在有GUI的情况下，只要我们能展示值班表的信息，这个职责事实上是可以转嫁给用户的，用户在查看值班表不满时会自行安排员工

### 课程管理系统

* 是否需要约定输入的日期必须是周一？
* 在用户安排了某节课后，为了程序的友好性，应该要提示这一节课离周学时数的上限还有多少节，即本周还能安排多少节(这个问题事实上您在设计课表系统的内部逻辑时应该已经考虑到了)，在到达上限后，应该在可以安排的课程中不显示该课程的信息以免造成误解
* step2中”添加一组课程“，这里同上面值班管理系统的问题
